```
% Calc rate of change of z

function [ dz ] = TransductionRHS_v6( t, z, opts, Vt, dt)
arguments
    t
    z
    opts
    Vt
    dt = 0
end

% if any(t)
%     disp(t)
% end

if opts.ode15s_
    if t == opts.tspan_array(end)
        dz = zeros(size(z));
        warning("Time did not increase.")
        return
    end
    opts.current_index = opts.current_index + 1;
    it = opts.current_index;
    dt_ = t - opts.tspan_array(end);
    opts.tspan_array(opts.current_index + 1) = t;
else
    dt_ = dt;
    % iteration index
    it = ceil(t/dt_);
end


Vt = Vt(:);

n = size(Vt,1);

m = decompose_z(z, 'CaV13_channels_fraction', opts.size_info);
Ca_blocked = decompose_z(z, 'CaV13_channels_blocked', opts.size_info);
C_vesicles = decompose_z(z, 'Ca_concentration', opts.size_info);
I = decompose_z(z, 'Ca_current', opts.size_info);
q = decompose_z(z, 'NT_free', opts.size_info);
c = decompose_z(z, 'NT_cleft', opts.size_info);
w = decompose_z(z, 'NT_reprocessing', opts.size_info);

c_proton = decompose_z(z, 'proton_cleft', opts.size_info);

m_old = m;
I_old = I;
Ca_blocked_old = Ca_blocked;
C_old = C_vesicles;

channels = opts.channels;
vesicles = opts.vesicles;
ps = opts.ps;


%%

[d_state_inactivated, d_state_normal, d_state_burst] = deal(zeros(1,n));

% number of Ca_V1.3 channels in the vicinity of the synapse
num_CaV13 = channels.num;


%%

p_block = CaV13.CaProtonBlock(c_proton);

% assert(dt_ / channels.tau_blocked <= 1);


%% Calculate rates

S0t = channels.S0t;
V0t = channels.V0t;

alpha = channels.alpha;
beta = alpha + 1/S0t;

kp0 = channels.kp0;

km0 = kp0 * exp(V0t * (beta - alpha));


%% Compute conductance

kp = kp0 * exp(-alpha * Vt); % E: Opening rate
km = km0 * exp(-beta * Vt);  % E: Closing rate

Q = [1 - kp*dt_, km *dt_; 
     kp*dt_, 1 - km*dt_];


% EVAN
% Q prob of transitioning between the closed (c) and open (o) states during a time step 
%   1st row: prob of remaining closed (1 - k_p * dt_) or transitioning to open (k_m \* dt_).
%   2nd row: prob of transitioning to closed (k_p * dt_) or remaining open (1 - k_m * dt_).

cQ = cumsum(Q,1);

ST = ['c', 'o'];


%% Determine Whether Channel is Open/Closed/Blocked
%   Based on membrane potential
for ii = 1:channels.num

    if channels.state(ii) == 'i' % inactivated
        continue
    end

    % Unblock channel
    if channels.state(ii) == 'b' % blocked
        if t >= channels.tblocked(ii)
            channels.state(ii) = 'c';
        else
            continue
        end
    end

    % Block channel
    % Check if channel becomes unblocked
    if rand(1) < p_block * dt_ / channels.tau_blocked

        % generate random close time from a gamma distribution
        % such that the mean (= a*b) is equal to the channels.tau_blocked
        %     a ... shape
        %     b ... scale

        a = 4;
        b = channels.tau_blocked / a;
        tau = b * gammaincinv(rand(1,1), a); % gamma random number without toolbox

        channels.state(ii) = 'b';
        channels.tblocked(ii) = t + tau;

    else
        r = rand(1);
    
        if channels.state(ii) == 'c' % closed
            st = 1;
        elseif channels.state(ii) == 'o' % open
            channels.topen(ii) = t; % last open time
            st = 2;
        else
            error('unknown state %s', channels.state(ii))
        end
        
        st_new = find(r < cQ(:,st), 1);
        try
            channels.state(ii) = ST(st_new);
        catch err
            throw(err)
        end

    end
end


m = sum(channels.state == 'o') / num_CaV13;
Ca_blocked = sum(channels.state == 'b') / num_CaV13;


%% Calculate concentration
% currently we calculate at two points:
%   1. close to the vesicle
%   2. close to the ion channel

all_channel_switch = true;
log_partial_concentrations = false;

if all_channel_switch
    ind_r_channel = 1:numel(ps);
else
    ind_r_channel = 1;
end

C_channels = zeros(numel(ps),1);
if it > 1
    for i = 1:numel(ps)
        if all_channel_switch
            if log_partial_concentrations
                C = ps{i}.concentration(ind_r_channel, it - 1);
            else
                C = ps{i}.concentration(ind_r_channel);
            end
            
            if any(isinf(C))
                warning('Infinite concentration detected at iteration %d for ps{%d}', it, i);
                disp('Concentration values:');
                disp(C);
                disp('Time: '); disp(t)
            end
            
            C_channels(i) = sum(C);
            
            % Check for unrealistic values and cap them
            % if C_channels(i) > 1e3  % Example cap, adjust based on realistic limits
            %     warning('Capping concentration at iteration %d for ps{%d}, C = %d', it, i, C_channels(i));
            %     C_channels(i) = 1e3;
            % end
        else
            C_channels{i} = ps{i}.concentration(ind_r_channel, it - 1);
        end
    end
end

C_channels = C_channels + opts.C_Ca_background;

open_channels = channels.state == 'o';


%% Calculate current

% Evan -
% I_GHK: Used for calculating calcium current flowing into hair cell
%   Needed for determing local concentration of Calcium
%       Which in tern is needed for calculating neurotransmitter release rate

% I_ohm = calcium_current(Vt, G_Ca, open_channels, C_channels);
% I_GHK = calcium_current_GHK(-70, G_Ca, open_channels, C_channels);
I_GHK = calcium_current_GHK(Vt, opts.G_Ca, open_channels, C_channels);

I = I_GHK;


for i = 1:numel(ps)
    ps{i}.current(it) = - I(i); % minus because of convention
    ps{i}.lastopen = channels.topen(i);
end

[C_vesicles, C_all] = calcium_concentration(vesicles, ps, it, all_channel_switch, opts);

for i = 1:numel(ps)
    if log_partial_concentrations
        ps{i}.concentration(:, it) = C_all(:, i);
    else
        ps{i}.concentration = C_all(:, i);
    end
end

C_vesicles = C_vesicles + opts.C_Ca_background;



%% Transmitter Release and Recycling

% dq : RoC of Neurotransmitter contents in the vesicle; Num_Vesicle x 1
% dc : RoC of Neurotransmitter concentration in the synaptic cleft ??
% dw : Neurotransmitter Reprocessing rate
% dc_proton : RoC of proton concentration in the synaptic cleft
% vesicles : Updated vesicle state with NT release events logged (not used)

[dq, dc, dw, dc_proton, vesicles] = NTdynamicsRHS_v6_core( t, ...
    q, c, w, c_proton, ...
    vesicles, opts, ...
    dt_, C_vesicles);


    
%% Build dz

% dm : RoC of fraction of open channels (m)
% dCa_blocked : RoC of fraction of blocked channels (Ca_blocked)
% dI : RoC of calcium current (I)
% dC : RoC of calcium concentration at the vesicles (C_vesicles)

dm = (m - m_old) / dt_;

dCa_blocked = (Ca_blocked - Ca_blocked_old) / dt_;

charge = 2;
amp_to_electron_per_second = 6.242e18;

I = sum(I) / amp_to_electron_per_second * charge;
dI = (I - I_old) / dt_;

dC = (C_vesicles - C_old) / dt_;

dz = [dm; dCa_blocked; dI; dC; dq; dc; dw; dc_proton];

d_state = [d_state_inactivated; d_state_normal; d_state_burst] / dt_;

% dz = [dz; d_state];

if any(isnan(dz))
    error('NaN encountered')
end


% disp(['Time: ', num2str(t), ' dt: ', num2str(dt_)]);
% disp(['State z: ', num2str(z')]);

% disp(['Rate of change dz: ', num2str(dz')]);


end


% - Evan - 
% Vm: Membrane potential
% G: Channel conductance
% area: membrane area
% Used for calculating calcium current flowing into hair cell

function I = calcium_current_GHK(Vm, G, m, C)
    arguments
        Vm (1,1) double
        G (1,1) double
        m (:,1) double  % num_channel x 1
        C (:,1) double  % num_channel x 1
    end
    
    
    % Ca2+ ion charge
    charge = 2;
    
    % extracellular concentration
    C_extracellular = 1.3e-3; % M
    
    T = 310; % [K] ~ 37C
    
    area = 1;
    
    me = 9.109383632e-31; % kg ... mass of electron
    ce = -1.602e-19; % C ... charge of electron
    
    fac = 6.0e-15 ; % m^3 / s^2 ... whatever this is
    P = G .* m / ce^2 / charge^2 * me * fac;
    P = P / area;
    
    Cin = C * 1000; % M to mol/m3
    Cout = C_extracellular * 1000; % M to mol/m3
    
    
    % charge ... charge [K]
    % T ... temperature [K]
    %
    % Phi is the current density (flux) across the membrane carried by ion S, measured in amperes per square meter (A·m−2)
    % arguments
    %     Vm double % transmembrane potential in volts
    %     Cin double % intracellular concentration of ion S, measured in mol·m−3 or mmol·l−1
    %     Cout double % extracellular concentration of ion S, measured in mol·m−3 or mmol·l−1
    %     P double = 1; % permeability of the membrane for ion S measured in m·s−1
    % end
    
    F = 96485.3328959;   % [C/mol]
    R = 8.314459848;     % [J/mol/K]
    
    % Phi = P * charge^2 * (Vm*F^2 / (R*T)) * (Cin - Cout*exp(-charge*Vm*F/(R*T))) / (1 - exp(-charge*Vm*F/(R*T)));
    
    U = charge * Vm * F / R / T;
    emU = exp(-U);
    % epU = exp(U);
    
    Phi = P .* charge * F * U .* (Cin - Cout.*emU) ./ (1 - emU);
    
    I = Phi * area;
    
    amp_to_electron_per_second = 6.242e18;
    
    I = I * amp_to_electron_per_second / charge; % ions/sec
        
    % figure
    % plot(t*1e3, chi.*j/1e3);
    % ylabel('Ca2+ flux (ion/ms)')
    % xlabel('time (ms)')

end

% vesicles: Struc w/ info about vesicles
% ps: Struct w/ channel properties and states
% it: Current iteration index
% all_channel_switch: Boolean to decide on full channel update
function [C_vesicle, C] = calcium_concentration(vesicles, ps, it, all_channel_switch, opts)
    arguments
        vesicles
        ps
        it
        all_channel_switch
        opts
    end

    if all_channel_switch
        ind_r_channel = numel(ps);
    else
        ind_r_channel = 1;
    end
    
    N_A = 6.02214076e23;  % Avogadro constant, mol^-1
    
    num_vesicles = vesicles.num;
    num_channels = numel(ps);
    
    % Concentration at each vesicle
    C_vesicle = zeros(num_vesicles, 1);

    % Concentration Matrix
    %   C(:, i) -> Particular channel i (column)
    %   C(1:num_channels, :) -> Channel i to all other Channels concentration
    %   C(num_channels:end, :) -> Channel i to all other Vesiclse concentration
    %   (num_vesicles + num_channels) x num_channels array
    C = zeros(ps{1}.nr, num_channels);   % Initialize concentration matrix
    
    % Calculate concentration from each channel
    for i = 1:num_channels
        if opts.ode15s_
            C(:, i) = ps{i}.dt_iterate(opts.tspan_array) / 1e3;
        else
            C(:,i) = ps{i}.e_iterate(it) / 1e3; % (num_vesicles + num_channels) x 1 array
        end
    end
    
    % Aggregate concentration for each vesicle
    for jj = 1:num_vesicles
        % Sum concentrations from channels close to this vesicle
        close_channels = vesicles.close_channels{jj};
        if isempty(close_channels)
            continue;
        end
        
        % Sum the concentrations from all relevant channels for this vesicle
        C_vesicle(jj) = sum(C(ind_r_channel + jj, close_channels));
    end
    
    % Normalize concentration
    C_vesicle = C_vesicle / N_A;  % Convert to mol/L (M)
    C = C / N_A;                  % Convert channel concentrations to mol/L (M)
end
    
    

function v = decompose_z(z, variable, size_info)

si = size_info.(variable);
v = z(si.start : si.end);

end
```

```
function [ dq, dc, dw, dc_proton, vesicles] = NTdynamicsRHS_v5_core( t, ...
    q, c, w, c_proton, ...
    vesicles, opts, ...
    dt, C_vesicles)
arguments
    t
    q % vesicule has transmitter (1) or not (0); 1xM array
    c 
    w
    c_proton
    vesicles
    opts
    dt % time step
    C_vesicles % calcium concentration of vesicle
end
%TRANSDUCTIONRHS

C_vesicles = C_vesicles(:);

M = vesicles.num;

%% Transmitter Release and Recycling

% kmax = opts.transmitter_release_parameters{1};
% n_Hill = transmitter_release_parameters{2};
% KA_Hill = transmitter_release_parameters{3};

% assert(kmax*dt <= 1)

% k1 ... single spot release rate
% k1 = kmax .* Hill_Langmuir_A(C_vesicles, n_Hill, KA_Hill);
k1 = RibbonSynapse_v4.TransmitterRelease(C_vesicles, opts.transmitter_release_parameters{:});

q_old = q;

% Nqk = number released from vesicle (random) <- dq : RoC of release
% Nwx = number reprocessed <- dc RoC of repocess
% NMqt = number created <- dw RoC of creation

% dc_proton <- RoC of proton concentration

% k1*dt is the amount of neurotransmitters release in the timeframe
Nqk = NTTransport(q, k1*dt, M); % number released from vesicle (random)
q = q - Nqk;

% disp("k1*dt"); disp(k1*dt)
% disp("q");disp(q)

% reprocessed
Nwx = NTReprocessing(~q, floor(w) * opts.x.Hz * dt, M); % number reprocessed
q = q + Nwx;

% disp("# reproc"); disp(Nwx);

% manufactured
NMqy = NTManufacture(~q, opts.y.Hz*dt, M);
q = q + NMqy;

% disp(q); disp(q_old); disp(dt);

% dq = (Nwx + NMqy - Nqk)/dt;
dq = (q - q_old) / dt;
dc = sum(Nqk) / dt - opts.l.Hz .* c - opts.r.Hz .* c;
dw = opts.r.Hz .* c - sum(Nwx) / dt;

dc_proton = sum(Nqk)/dt - 0.9 * opts.l.Hz .*c_proton;

for i = 1:sum(Nqk)
    vesicles.logReleaseEvent(t);
end

% https://github.com/evanwporter/cochlea-nerve/blob/4e8b4f18f20782bfc39d88589db9f4e04dbcf507/IHC/Transduction_v4.m#L147-L148

%% Stochastic NT Transport

% n: # vesicles

function N = NTReprocessing(q, rho, n)
    n_empty = sum(q);
    try
        if n_empty > 0 && rho > 0
            N = q & (rand(n,1) < (rho / n_empty));
        else
            N = zeros(size(q));
        end
    catch exception
        disp("n_empty");disp(n_empty)
        disp("rho");disp(rho)
        disp("q");disp(q)
        disp("n");disp(n)
        throw(exception)
    end
end

function N = NTManufacture(q, rho, n)
    n_empty = sum(q);
    if n_empty > 0
        try     
            N = q & (rand(n,1) < (rho / n_empty));
        catch exception
            disp("n_empty");disp(n_empty)
            disp("rho");disp(rho)
            disp("q");disp(q)
            disp("n");disp(n)
            throw(exception)
        end
    else
        N = zeros(size(q));
    end
end
function N = NTTransport(q, rho, n)
    n_occupied = sum(q); % number occupied
    % disp("n_occupied"); disp(n_occupied)
    if n_occupied > 0
        try
            N = q & (rand(n,1) < rho);
        catch exception
            disp(q);
            disp(rho);
            disp(n)
            throw(exception)
        end
    else
        N = zeros(size(q));
    end
end


end
```

```
function [theta] = Hill_Langmuir_A(L, n, KA)
%HILL_LANGMUIR 
% https://en.wikipedia.org/wiki/Hill_equation_(biochemistry)
%
% theta ... fraction of the receptor bound by the ligand
% L     ... ligand concentration
% KA    ... ligand concentration producing half occupation
% n     ... Hill coeficient

theta = 1 ./ (1 + (KA./L).^n);

end
```

```
classdef PointSource < handle
    %POINTSOURCE

    % Evan's Notes
    % d : dimensionality
    % D : diffusion coefficient
    % r : vector of distances from the point source to the point of interest

    
    properties
        d
        D
        r
        
        nr
        nt
        
        dt

        method
        
        N (1,1) double = +inf; % max history
        
        u1_const
        
        rel_tol

        test_var
        time_array % evan
        G_array

    end
    properties % (Transient) % transient property acces is slow (R2022a)
        e_pre
        e_pre_rev

        lastopen
        
        current (1, :) double;
        concentration

        E
    end
    
    methods
        function obj = PointSource(d, D, r, dt, it, args)
            arguments
                d  (1,1) double {mustBePositive, mustBeInteger, mustBeLessThanOrEqual(d, 3)}
                D  (1,1) double {mustBePositive}
                r  (:,1) double {mustBePositive}

                dt (1,1) double {mustBeNonnegative} = 0
                it (1,:) double {mustBeNonnegative} = 0

                args.method string = "ondrej"; % Other methods are evan and ode15s

                args.max_history (1,1) double {mustBePositive} = +inf
                args.rel_tol (1,1) double {mustBeNonnegative} = 0
                args.log_concentration (1,1) logical = false

                % args.tspan (1, 2) double{mustBeNonnegative} = 0
            end
            %POINTSOURCE
            
            obj.d = d;
            obj.D = D;
            obj.r = r;
            
            obj.nr = numel(r);

            obj.method = args.method;

            if not(obj.method == "ode15s")
                    
                obj.nt = numel(it);

                obj.lastopen = -inf;
                
                obj.dt = dt;
                
                obj.rel_tol = args.rel_tol;

                if args.rel_tol > 0 && args.max_history < +inf
                    error('only one argument can be set to non-default value')
                end
                
                if args.rel_tol > 0 || args.max_history < +inf
                    approximation = true;
                else
                    approximation = false;
                end
                
                %%
                
                obj.e_pre_rev = obj.e(flip(it)); % reversed order

                
                
                %%
                
                if args.rel_tol > 0
                    N = obj.find_max_history(args.rel_tol);
                    % fprintf('History of %d steps required for %g rel error.\n', N, args.rel_tol)
                elseif isfinite(args.max_history)
                    N = args.max_history;
                else
                    N = obj.nt;
                end
                
                mustBeInteger(N)
                obj.N = N;
                
                tdim = 2;
                
                debug = false;
                
                if approximation == true
                    approx_error_est = sum(obj.e_pre_rev(:,1:obj.nt - N), tdim) ./ sum(obj.e_pre_rev, tdim);

                    if debug == true
                        dbprintf('Approximation error estimate\n');
                        for i = 1:obj.nr
                            dbprintf('%8.2f%%   ... for r = %g\n', approx_error_est(i) * 100, r(i));
                        end
                    end

                    assert(all(approx_error_est < obj.rel_tol), sprintf('Error estimate > %g%%', obj.rel_tol * 100));

                    itt = flip(it(1:N));
                    obj.e_pre_rev = obj.e(itt); % reversed order

                end
                
                if args.log_concentration
                    obj.concentration = zeros(obj.nr, obj.nt);
                end

                obj.current = zeros(1, obj.nt);

            end

            obj.G_array = PrecomputeGreen(reshape(obj.r,1,[]), it, D);

            % obj.test_var = (2 / (4 * pi * obj.D .* obj.r)) * erfc(obj.r ./ sqrt(4 * obj.D .* it));
        end
        % -----------------------------------------------------------------
        function N = find_max_history(obj, tol)
            
            tdim = 2;
            
            err_est = cumsum(obj.e_pre_rev, tdim);

            % Gives the fraction of the total cumulative effect up to each time step
            rel_err_est = err_est ./ err_est(:,end);
            
            ind = zeros(obj.nr, 1);
            for i = 1:obj.nr
                ind(i) = find(rel_err_est(i,:) > tol, 1) - 1;
            end
            assert(all(ind > 0));
            N = obj.nt - min(ind);
            
        end

        c = e_iterate(obj, it)        

        function C = dt_iterate(obj, time_array)
            arguments
                obj
                time_array (1, :) double {mustBeNonnegative}
            end
            % t : time at which to evaluate the concentration
            % r : array of distances from the source
            % D : diffusion coefficient
            % I : function handle for the source term I(t')
            % dt : time step for the approximation

            C = zeros(1, obj.nr);
            
            t = time_array(end);
            
            GF = @(t, t_prime, r) (4 * pi * obj.D * (t - t_prime))^(-3/2) * exp(-r^2 / (4 * obj.D * (t - t_prime)));
            
            for i = 1:obj.nr
                for j = 2:(length(time_array) - 1)
                    t_prime = time_array(j);
                    dt = t_prime - time_array(j - 1);
                    G = GF(t, t_prime, obj.r(i));
                    C(i) = C(i) + obj.current(j) * G * dt;
                end
            end
        end

        function c = simple_iterate(obj, it)
            % Evan's Simple version of iterate
            % Same as PointSource.iterate when PointSource.N == 1

            assert(obj.d == 3, "Requires dimensionality of 3")
            c = zeros(obj.nr, 1);

            current_t = it * obj.dt;

            for i = 1:length(obj.r)
                c(i) = 2 * (obj.current(it) / (4 * pi * obj.D * obj.r(i))) * erfc(obj.r(i) / sqrt(4 * obj.D * current_t));
                % c(i) = obj.test_var(it) .* obj.current(it);
            end

            % Precompute the following:
            % 2 / (4 * pi * obj.D .* obj.r) * erfc(obj.r ./ sqrt(4 * obj.D .* it))
        end

        function cc = iterate(obj, it)
            arguments
                obj
                it (1,1) double    
            end
        
            cc = zeros(obj.nr, 1);
            % current_t = it * obj.dt;
        
            last_it_open = obj.lastopen / obj.dt;
            if last_it_open < it - obj.N
                return
            end
            n = it;
        
            u_ondra_mex(obj.current, obj.e_pre_rev, n, n, obj.N, obj.nt, cc);
            % cc = obj.u_ondra(obj.current, obj.e_pre_rev, n, obj.N, obj.nt, obj.nr);
        
            % Error prevention
            if any(isinf(cc | isnan(cc)))
                disp(obj.u_ondra(obj.current, obj.e_pre_rev, n, obj.N, obj.nt, obj.nr));
                fprintf('Iteration: %d, Concentration: %f\n', it, cc);
                fprintf('Current: %f, e_pre_rev: %f\n', obj.current, obj.e_pre_rev);
                error('Divergence detected at iteration %d\n', it);
            end
        
                % c(:, i) = obj.u(obj.current,n,n);
                % c(:, i) = obj.u_mex(obj.current,n,n);
            
                % cc(:, i) = obj.u(obj.current,n,n);
                % if c(:,i) ~= 0
                %     assert(all(abs((c(:,i)-cc(:,i))./c(:,i)) < 1e-14))
                % end
            
            % From the paper
            % For d = 1 and d = 3, Eq. (1) assumes that the ions are diffusing
            % into open space on both sides of the membrane. However, in the 
            % ion channel situation, we are only interested in the ions 
            % diffusing into the compartment on one side of the membrane. 
            % Therefore, in these two geometries, one must use twice the 
            % channel flux in the equations.
            
            if obj.d == 1 || obj.d == 3                
                % since u is linear with respect to j, we can multiply c
                cc = cc * 2; % mols/m^3
            end
            
        end

        V = u_ondra(obj, J, E, n, nn, N, nt, nr)

        % -----------------------------------------------------------------

        function val = e(obj, m)
            val = obj.u2((m+1) * obj.dt) - obj.u2(m * obj.dt);
        end

        function u2 = u2(obj, t)
            assert(obj.d == 3, "Dimensionality must be 3 to use u2.")
            u2 = (obj.r.^(2-obj.d) / (4*obj.D*pi^(obj.d/2))) .* ... 
                 (sqrt(pi) * erfc(obj.r ./ sqrt(4*obj.D*t)));
        end
    end
end
```

```
function SynapseDynamics()

    % Voltage step to simulate
    Vt = -.01; % Voltage in mV
    voltage_steps = linspace(-.07, -.005, 20);
    % voltage_steps = voltage_steps(10);
    
    opts = SynapseOptions();

    % To reproduce results
    rng(opts.seed, "twister") 
    
    if opts.ode15s_
        tspan = opts.tspan;
    else
        tspan = opts.tspan_array;
        solveropt = solverOpt('TimeStep', opts.dt);
    end

    % Initialize results
    release_rates = zeros(1, length(voltage_steps));
    % results = zeros(1001, 34, length(voltage_steps));

    opts.initial_state = initialize_synapse_state(opts);
    

    % rs_s = ["r1"; "r2"; "i1"; "i2"; "i3"; "i4"; "i5"];
    % 
    % for rs = 1:length(rs_s)
    %     opts.rs = getSynapse(rs_s(rs));
    %     disp(rs_s(rs))
    for v = 1:length(voltage_steps)
        Vt = voltage_steps(v);

        if opts.ode15s_
            warning("Ode15s is  experimental at this moment.")
            options = odeset('RelTol',1e-3, 'AbsTol',1e-6, 'InitialStep', 1e-4);
            [t_out, y_out] = ode15s(@(t, z) TransductionRHS_v6(t,z,opts,Vt), opts.tspan, opts.initial_state, options);
        else
            [t_out, y_out] = odeEuler(@TransductionRHS_v6, tspan, opts.initial_state, solveropt, ...
                                    opts, Vt, opts.dt);
        end
        
        v_s = num2str(Vt);
        v_s = v_s(4:end);
        v_s(end+1:end+10) = "_mv_e_1e_3";

        save(v_s, "y_out");
        % results(:,:,v) = y_out;
        release_rates(v) = calc_q_released(t_out, y_out, opts);
    end
    % 
    % end

    % Plot release rates against voltage steps
    figure;
    plot(voltage_steps, release_rates, '-o');
    xlabel('Voltage (V)');
    ylabel('Neurotransmitter Release Rate');
    title('Neurotransmitter Release Rate vs Voltage');
    grid on;



    disp(release_rates)

    % initial_state = initialize_synapse_state(opts);
    % solveropt = solverOpt('TimeStep', opts.dt);

    % % Simulation using odeEuler with TransductionRHS_v5
    % [t_out, y_out] = odeEuler(@TransductionRHS_v6, tspan, initial_state, solveropt, ...
    %                           opts, opts.dt, Vt);

    % calc_q_released(t_out, y_out, opts);

    % % For debugging: Display output (y_out, t_out)
    % disp("Simulation complete.");
    % plot(t_out, decompose_z(y_out, 'NT_free', opts.size_info));
    % xlabel('Time (s)');
    % ylabel('State Variables');
    % title('Synapse Dynamics Simulation');
end

% Helper function to initialize the state vector
function initial_state = initialize_synapse_state(opts)
    m_initial = 0;    
    Ca_blocked_initial = 0;    
    I_initial = 0;    
    C_vesicles_initial = opts.C_initial * ones(opts.num_vesicles, 1);
    q_initial = ones(opts.num_vesicles, 1);
    c_initial = 0;    
    w_initial = 0;
    c_proton_initial = 0;

    initial_state = [m_initial; Ca_blocked_initial; I_initial; C_vesicles_initial; ...
                     q_initial; c_initial; w_initial; c_proton_initial];
end


function total_release = calc_q_released(t, z_array, opts)
    q_start = opts.size_info.NT_free.start;
    q_end = opts.size_info.NT_free.end;

    q_values = z_array(:, q_start:q_end);

    % Calculate total release by summing the decreases in q
    total_release = 0;
    for i = 2:length(t)
        try
            released_this_step = q_values(i - 1, :) - q_values(i, :);
        catch e
            throw(e)
        end
        total_release = total_release + sum(released_this_step(released_this_step > 0));
    end

    disp("Total neurotransmitter released: " + total_release);
end

function v = decompose_z(z, variable, size_info)

si = size_info.(variable);
v = z(:, si.start : si.end);

end
```

```
classdef SynapseOptions < handle % handles allows updating properties by reference
    properties (SetAccess = immutable)
        % https://github.com/evanwporter/cochlea-nerve/blob/4e8b4f18f20782bfc39d88589db9f4e04dbcf507/Wrapper/Options/transductionOpt_v4_1.m#L354-L355
        num_release_sites (1,1) {mustBePositive, mustBeInteger} = 14;
        num_CaV13 (1,1) {mustBePositive, mustBeInteger} = 72;

        % https://github.com/evanwporter/cochlea-nerve/blob/50d39b91828e149530a871f8f2cffa432c6c53f0/Wrapper/Options/transductionOpt_v4_1.m#L15-L18
        Ca_diffusion_coefficient (1,1) double {mustBePositive} = 5.2e-10;

        % https://github.com/evanwporter/cochlea-nerve/blob/50d39b91828e149530a871f8f2cffa432c6c53f0/Wrapper/Options/transductionOpt_v4_1.m#L8-L11
        Ca_conc_rel_tol (1,1) double {mustBeNonnegative} = 10e-2;

        % https://github.com/evanwporter/cochlea-nerve/blob/50d39b91828e149530a871f8f2cffa432c6c53f0/Wrapper/Options/transductionOpt_v4_1.m#L339
        d_nernst (1,1) double {mustBeNonnegative} = 20e-9;

        num_inactive_release_sites (1,1) {mustBeNonnegative, mustBeInteger} = 0;

        num_vesicles (1,1) {mustBeNonnegative, mustBeInteger};

        tau_CaV13  % see Zampini 2010 Table 1
        tau_CaV13_blocked

        channels Channels;
        vesicles Vesicles;

        y Frequency;
        l Frequency;
        x Frequency;
        r Frequency;

        transmitter_release_parameters

        % https://github.com/evanwporter/cochlea-nerve/blob/50d39b91828e149530a871f8f2cffa432c6c53f0/Wrapper/Options/transductionOpt_v4_1.m#L80-L82
        channels_markov_properties struct = struct('alpha', -133, 'kp0', 5e5);

        channels_open_ss_parameters_normal cell;
        channels_open_ss_parameters_burst cell;

        ps

        C_initial (1,1) double {mustBePositive} = 1e-7; % Initial calcium concentration in M

        % https://github.com/evanwporter/cochlea-nerve/blob/cc845a8870e4825796b05a13568a15e4361ce6cf/IHC/Transduction_v4.m#L75-L81
        C_Ca_background_base (1,1) double {mustBePositive} = 17.1e-6; % M
        C_Ca_background_apex (1,1) double {mustBePositive} = 40.6e-6; % M

        % https://github.com/evanwporter/cochlea-nerve/blob/50d39b91828e149530a871f8f2cffa432c6c53f0/Wrapper/Options/transductionOpt_v4_1.m#L27-L28
        C_Ca_background_factor (1,1) double {mustBePositive} = 1;

        C_Ca_background (1,1) double;

        % Position property, must be between 0 and 1 (I think)
        x_pos (1,1) double {mustBeGreaterThanOrEqual(x_pos, 0), mustBeLessThanOrEqual(x_pos, 1)} = 0.5;

        size_info struct;

        simulation_units struct = struct( ...
            'Voltage', 'V', ...
            'Frequency', 'Hz', ...
            'Concentration', 'M', ...
            'Time', 's'...
        );

        % Calcium Conductance
        % https://github.com/evanwporter/cochlea-nerve/blob/50d39b91828e149530a871f8f2cffa432c6c53f0/Wrapper/Options/transductionOpt_v4_1.m#L333
        G_Ca (1,1) double {mustBePositive} = 15e-12;

        % Time Related Properties
        ode15s_ (1,1) logical = false;
        dt (1,1) double {mustBePositive} = 1e-4;
        tspan double {mustBeReal, mustBeFinite, mustBeNonnegative};

        ribbon_synapse_properties struct;
        h1 double;

        seed (1,1) double = 21;

    end

    properties
        rs RibbonSynapse_v5;
        
        current_index (1, 1) double {mustBeNonnegative} = 0;

        tspan_array (1, :) double;

        initial_state
    end
    
    methods
        function obj = SynapseOptions()

            uconv = @(var) Unit.batch_convert(obj.simulation_units, var);

            obj.num_vesicles = obj.num_release_sites - obj.num_inactive_release_sites;

            
            %% Set Time


            if not(obj.ode15s_)
                obj.tspan = [0 obj.dt * 1e3];
                obj.tspan_array = obj.tspan(1):obj.dt:obj.tspan(end);
            else
                obj.tspan = [obj.dt 10];
                obj.tspan_array = [0];
            end

            [numSteps, numSamples] = odeEuler_tspan(obj.tspan, obj.dt);

            %% Channels

            % https://github.com/evanwporter/cochlea-nerve/blob/4e8b4f18f20782bfc39d88589db9f4e04dbcf507/Wrapper/Options/transductionOpt_v4_1.m#L335-L336
            obj.tau_CaV13 = Time(500, 'us');        % Calcium channel time constant
            obj.tau_CaV13_blocked = Time(1, 'ms');  % Blocked state time constant

            % https://github.com/evanwporter/cochlea-nerve/blob/cc845a8870e4825796b05a13568a15e4361ce6cf/IHC/Transduction_v4.m#L147-L148
            obj.channels = Channels(obj.num_CaV13, obj.tau_CaV13.s, obj.tau_CaV13_blocked.s);

            obj.x_pos = .5;

            obj.transmitter_release_parameters = uconv(obj.generate_transmitter_release_parameters(obj.x_pos));
            
            % https://github.com/evanwporter/cochlea-nerve/blob/50d39b91828e149530a871f8f2cffa432c6c53f0/IHC/Transduction_v4.m#L64-L65
            obj.channels_open_ss_parameters_normal = uconv(obj.generate_channels_open_ss_parameters('normal', obj.x_pos));
            obj.channels_open_ss_parameters_burst = uconv(obj.generate_channels_open_ss_parameters('burst', obj.x_pos));
            
            V0t = obj.channels_open_ss_parameters_normal{1};
            S0t = obj.channels_open_ss_parameters_normal{2};
    
            obj.channels.alpha = obj.channels_markov_properties.alpha;
            obj.channels.kp0 = obj.channels_markov_properties.kp0;
            obj.channels.V0t = V0t;
            obj.channels.S0t = S0t;

            % https://github.com/evanwporter/cochlea-nerve/blob/4e8b4f18f20782bfc39d88589db9f4e04dbcf507/IHC/Transduction_v4.m#L514-L515
            obj.vesicles = Vesicles(obj.num_vesicles);

            % https://github.com/evanwporter/cochlea-nerve/blob/50d39b91828e149530a871f8f2cffa432c6c53f0/IHC/Transduction_v4.m#L213-L228
            for i = 1:obj.num_vesicles
                obj.vesicles.close_channels{i} = 1:obj.num_CaV13;
            end

            %% https://github.com/evanwporter/cochlea-nerve/blob/4e8b4f18f20782bfc39d88589db9f4e04dbcf507/Wrapper/Options/transductionOpt_v4_1.m#L38-L50
            obj.y = Frequency(10, 'Hz'); % Sumner 2002
            obj.l = Frequency(1290, 'Hz'); % to roughly match the time-constant of H&H
            obj.x = Frequency(66.3, 'Hz'); % Sumner 2002
            obj.r = Frequency(3290, 'Hz'); % to roughly match the time-constant of H&H

            % obj.rs = RibbonSynapse_v5( ...
            %     'plotflag', true, ... 
            %     'channel_distribution_method', 'uniform', ...
            %     'num_channels', obj.num_CaV13, ...
            %     'num_release_sites', obj.num_release_sites ...
            % );

            obj.rs = RibbonSynapse_v5( ...
                'plotflag', true, ...
                'plot_histograms', false, ...
                'channel_distribution_method', 'regular_band_n', ...
                'channel_distribution_parameters', struct(...
                    'length', 24*20, ...
                    'wpos', [-40, 0, 40] ...
                ), ...
                'num_channels', obj.num_CaV13, ...
                'num_release_sites', obj.num_release_sites, ...
                'vesicle_radius', 40, ...
                'intervesicle_distance', 100 ...
            );

            % https://github.com/evanwporter/cochlea-nerve/blob/7911ffcf2ec1e14a187fbaf46c3635fc3d6ff42d/Wrapper/Options/transductionOpt_v4_1.m#L361-L377
            % obj.ribbon_synapse_properties = struct( ...
            %     'distance_vesicle_membrane', 5, ... nm
            %     'intervesicle_distance', [60,80], ...
            %     'channel_radius', 4, ...
            %     'vesicle_radius', 20 ...
            % );
            % obj.ribbon_synapse_properties.channel_distribution_method = 'LJ';
            % obj.ribbon_synapse_properties.channel_distribution_parameters = struct( ...
            %     's', 500, ...
            %     'epsilon0', 0.1, ...
            %     'r0', 130, ...
            %     'n0', 4, ...
            %     'm1', 10, ...
            %     'h1', obj.h1, ...
            %     's1', 3 ...
            % );
            % tmp = namedargs2cell(obj.ribbon_synapse_properties);
            % obj.rs = RibbonSynapse_v5(tmp{:});

            %% Create PointSources
            d = 3; % geometry factor
            for i = 1:obj.num_CaV13
                rho = obj.rs.rho(:,i) * 1e-9; % channel mouth--vesicle membrane distance
                psi = obj.rs.psi(:,i) * 1e-9; % channel mouth--channel mouth distance
                psi_nernst = sqrt(psi.^2 + obj.d_nernst.^2); % channel mouth--channel nernst point (above channel mouth)
                r = [psi_nernst; rho];
                % if obj.ode15s_
                %     obj.ps{i} = PointSource(d, obj.Ca_diffusion_coefficient, r, 'method', 'evan');
                % else
                %     obj.ps{i} = PointSource(d, obj.Ca_diffusion_coefficient, r, obj.dt, 0:numSamples, 'rel_tol', obj.Ca_conc_rel_tol);
                % end
            end

            %% https://github.com/evanwporter/cochlea-nerve/blob/cc845a8870e4825796b05a13568a15e4361ce6cf/IHC/Transduction_v4.m#L75-L81
            obj.C_Ca_background = obj.C_Ca_background_base + (obj.C_Ca_background_apex - obj.C_Ca_background_base) * obj.x_pos;
            obj.C_Ca_background = obj.C_Ca_background * obj.C_Ca_background_factor;

            % https://github.com/evanwporter/cochlea-nerve/blob/4e8b4f18f20782bfc39d88589db9f4e04dbcf507/IHC/Transduction_v4.m#L317-L328
            obj.size_info = create_size_info( ...
                "CaV13_channels_fraction", 1, ...         % m
                "CaV13_channels_blocked", 1, ...          % Ca_blocked
                "Ca_current", 1, ...                      % I
                "Ca_concentration", obj.num_vesicles, ... % C_vesicles
                "NT_free", obj.num_vesicles, ...          % q
                "NT_cleft", 1, ...                        % c
                "NT_reprocessing", 1, ...                 % w
                "proton_cleft", 1, ...                    % c_proton
                "CaV13_num_inactivated", 1, ...           % CaV13_num_inactivated
                "CaV13_num_normal", 1, ...                % CaV13_num_normal
                "CaV13_num_burst", 1);                    % CaV13_num_burst

        end

        % https://github.com/evanwporter/cochlea-nerve/blob/50d39b91828e149530a871f8f2cffa432c6c53f0/Wrapper/Options/transductionOpt_v4_1.m#L130-L140
        function params = generate_transmitter_release_parameters(obj, x_pos)
            
            % https://github.com/evanwporter/cochlea-nerve/blob/50d39b91828e149530a871f8f2cffa432c6c53f0/Wrapper/Options/transductionOpt_v4_1.m#L341-L350
            transmitter_release_parameters = struct( ...
                'apex', {{ ...
                    Frequency(500, 'Hz'), ...
                    5.0, ...      % Hill's coefficient
                    100e-6}}, ... % Half activation [Ca2+ M]
                'base', {{ ...
                    Frequency(500, 'Hz'), ...
                    5.0, ...
                    100e-6}} ...
            );

            par_base = transmitter_release_parameters.base;
            par_apex = transmitter_release_parameters.apex;

            params = cell(numel(par_base), 1);
            for i = 1:numel(par_base)
                params{i} = par_base{i} + (par_apex{i} - par_base{i}) * x_pos;
            end

        end

        % https://github.com/evanwporter/cochlea-nerve/blob/50d39b91828e149530a871f8f2cffa432c6c53f0/Wrapper/Options/transductionOpt_v4_1.m#L142-L153
        function params = generate_channels_open_ss_parameters(obj, mode, x_pos)
            
            % https://github.com/evanwporter/cochlea-nerve/blob/50d39b91828e149530a871f8f2cffa432c6c53f0/Wrapper/Options/transductionOpt_v4_1.m#L53-L77
            channels_open_ss_parameters = struct( ...
                'normal', struct( ...
                    'apex', {{ ...
                        Voltage(-23.4, 'mV'), ...   % [V] - IHC voltage - half-activation boltzmann function parameter
                        Voltage(8, 'mV'), ... % [V] - IHC voltage - slope boltzmann function parameter
                        0.0, 1, ...
                        }}, ...
                    'base', {{ ...
                        Voltage(-25.9, 'mV'), ...   % [V] - IHC voltage - half-activation boltzmann function parameter
                        Voltage(7.4, 'mV'), ...  % [V] - IHC voltage - slope boltzmann function parameter
                        0.0, 1, ...
                        }} ...
                ), ...
                'burst', struct( ...
                    'apex', {{ ...
                        Voltage(0, 'mV'), ...
                        Voltage(1, 'mV'), ... % [V] - IHC voltage - slope boltzmann function parameter
                        0, 1, }}, ...
                    'base', {{ ...
                        Voltage(0, 'mV'), ...
                        Voltage(1, 'mV'), ...  % [V] - IHC voltage - slope boltzmann function parameter
                        0, 1, }} ...
                ) ...
            );
            
            par_base = channels_open_ss_parameters.(mode).base;
            par_apex = channels_open_ss_parameters.(mode).apex;
            
            % linear model
            params = cell(numel(par_base), 1);
            for i = 1:numel(par_base)
                params{i} = par_base{i} + (par_apex{i} - par_base{i}) * x_pos;
            end
        end
    end
end
```

```
% Evan's Notes 6/18/2024
% Class models structure of ribbon synapse.
% In particular distribution of calcium channels
%   and vesicles and release of neurotransmitters
% See figure 8 / section 2.9 of text


% RibbonSynapse::rho <- distance between Ca channels and vesicles
% RibbonSynapse::psi <- distance between Ca channels and other channels

% RibbonStnapse_v4::TransmitterRelease <- Computes the rate of transmitter 
%   release based on calcium concentration using Hill-Langmuir equation

% RibbonSynapse
% Input Parameters
%     num_channels: Number of calcium channels.
%     xv: Coords of vesicles.
%     xc: Coords of calcium channels.
%     distance_vesicle_membrane: Distance from vesicle membrane to calcium channels.
%     channel_radius: Radius of calcium channels.
%     vesicle_radius: Radius of vesicles.
%     

% num_release_sites: # vesicles -> n
% num_channels: # channels      -> M

% rho is n x M matrix
% rho is distance between each vesicle and each calcium channel 
%   Euclidean distance ( |abs| ) - vesicle radius
%   Calculated in the constructor.
%   

% cochlea-nerve\IHC\Transduction_v4_multi.m
% f_TransmitterRelease = @(C) RibbonSynapse.TransmitterRelease(C, tr_par{:});
% Returned then by Transduction_v4_multi

% Transduction_v4_multi called by Synapse
% cochlea-nerve\IHC\Synapse.m

% From there its saved to a mat file
% At replicas.dir

% Synapse is called by setSynapseResult
% cochlea-nerve\Wrapper\Database\setSynapseResult.m
% Replicas is passed to setSynapseResult

% C:\Users\evanw\cochlea-nerve\Wrapper\Database\handleResult.m
% handleResult.m creates anon func
% model = @(rep) setSynapseResult( rep, ...
%   const_src_data{:}, topt, antopt, runopt, paropt, memopt, ...
%   antopt.fiber, setStructure ...
% );

% called here -> N = model(replicas(ind.create | ind.extend));

% replicas(i).dir = res_dir


% Alternatively TransmitterRelease is called by NTdynamicsRHS_v5_core
% Which is passed concentration
% Its is passed concentration by TransductionRHS_v5
% C:\Users\evanw\cochlea-nerve\IHC\TransductionRHS_v5.m

% Calcium concentration is created by Calcium concentration function

classdef RibbonSynapse_v5
    %RibbonSynapse 
    
    properties
        rho
        psi
        
        xv
        xc
        method
        
        num_release_sites;
        num_channels;
        
        distance_vesicle_membrane
        intervesicle_distance
        
        channel_radius
        vesicle_radius
        
        channel_distribution_method
        channel_distribution_parameters

        area
    end
    
    methods (Static)
        % function k = TransmitterRelease(C, k_max, H, S)
        %     %TRANSMITTERRELEASE 
        % 
        %     k = boltzmann(C, k_max, H, S);
        % end
        function k = TransmitterRelease(C, k_max, n, KA)
            % E Notes - 
            %   k_max: max neurotransmitter release
            %   C: calcium concentration        
            k = k_max .* Hill_Langmuir_A(C, n, KA);
            %   scaled between 0 and k_max
            % k: is a 1 x M vector (where M is number of vesicles)
            %   Each element representes the number of neurotransmitters released
            %       per unit of time 
        end 
    end
    
    methods
        function obj = RibbonSynapse_v5(args)
            %RibbonSynapse
            % 74 Ca2+ channels (see text) and 14 docked vesicles (Wong et al., 2014).
            % The diameter of Ca2+ channels is ∼15 nm (Wolf et al., 2003), while that of vesicles is
            % ∼40 nm (Khimich et al., 2005). Placing 74 Ca2+ channels closely packed
            % (7.5 nm minimum distance) gives a presynaptic area of ∼0.033 µm2 , which is
            % consistent with the most recent EM estimates (0.066 µm2 ; Khimich et al.,
            % 2005) and STED microscopy (0.11 µm2 and 0.097 µm2 for apical and middle
            % cochlea IHCs, respectively: Meyer e al., 2009; 0.034 µm2 for mature IHCs:
            % Wong et al., 2014)
            arguments
                
                args.num_release_sites (1,1) double {mustBeInteger, mustBePositive} = 14
                args.num_channels (1,1) double {mustBeInteger, mustBePositive} = 5
                
                args.distance_vesicle_membrane (1,1) double {mustBePositive} = 20 % nm
                args.intervesicle_distance (1,2) double {mustBePositive} = [55,55] % nm

                args.channel_radius (1,1) double {mustBePositive} = 7.5 % nm
                args.vesicle_radius (1,1) double {mustBePositive} = 20 % nm
                
                args.channel_distribution_method (1,:) char = 'uniform_ring'
                
                args.channel_distribution_parameters (1,:) struct = ...
                    struct('dist_min', 7.5 + 15, ...
                           'dist_max', 40, ...
                           'exclusion_dist_vesicle', 7.5 + 15, ...
                           'exclusion_dist_channel', 2*7.5 + 1);
                       
                args.plotflag (1,1) logical = false
                args.plot_histograms (1,1) logical = true
            end
            
            f = fieldnames(args);

            % EVAN 6/18/2024 - adds these two flags to f if they aren't already there
            f = setdiff(f, {'plotflag', 'plot_histograms'}); 

            for i = 1:numel(f)
                obj.(f{i}) = args.(f{i});
            end
            
            %%
            
            n = obj.num_release_sites;
            M = obj.num_channels;
            
            assert(mod(n, 2) == 0)
            
            obj.xv = NaN(n, 2);
            
            % Rectangular distribution
            for i = 1:n
                obj.xv(i, 1) = floor((i-1)/2);
                obj.xv(i, 2) = mod(i,2);
            end
            
            obj.xv = obj.xv .* obj.intervesicle_distance;
            
            %% Channel distribution
            
            % Returns channels.num x 2 matrix
            % x-coordinates of channels
            obj.xc = obj.channel_distribution(n, M);


            %% Add 3rd dimension
            % Evan:
            % We can think of the 3rd dimension as the vertical distance from the membrane
            % The membrane is located at z = 0
            
            % EP
            % Distance from center of vesicle to membrane
            %   Num_Channels x 2
            %   Distance of vesicle (outer shell) from membrane + Vesicle radius
            %   This makes (at minimum) the vesicle shell touching the vesicle membrane
            obj.xv(:,3) = obj.distance_vesicle_membrane + obj.vesicle_radius;

            % EP
            % Distance from center of channel to membrane
            %   Num_Vesicles x 2
            %   This places the channel on the membrane
            obj.xc(:,3) = 0;
            

            %% Compute euclidean distances
            
            % dist channel -- vesicle membrane
            % EP: rho is Num_Vesicles x Num_Channels
            obj.rho = zeros(n, M);
            for i = 1:n % EP Loops vesicle by vesicle
                obj.rho(i,:) = sqrt(sum((obj.xc - obj.xv(i,:)).^2, 2)) - obj.vesicle_radius;
            end

            assert(all(obj.rho(:) >= 0));
            
            % dist channel -- channel
            % EP: psi is Num_Channels x Num_Channels
            obj.psi = zeros(M, M);
            for i = 1:M % EP Loops channel by channel
                obj.psi(i,:) = sqrt(sum((obj.xc - obj.xc(i,:)).^2, 2));
            end
            
            a1 = min(obj.xc(:,1));
            b1 = max(obj.xc(:,1));
            
            a2 = min(obj.xc(:,2));
            b2 = max(obj.xc(:,2));
            
            area = (b1-a1)*(b2-a2);
            
            obj.area = area;
            
            %% Plotting
            
            if args.plotflag == true
            
                % figure
                % hold on
                % plot(obj.xv(:,1), obj.xv(:,2), 'bo')
                % plot(obj.xc(:,1), obj.xc(:,2), 'rx')
                % axis equal
                % 
                % figure
                % hold on
                % plot3(obj.xv(:,1), obj.xv(:,2), (0.4 + 0.2)*ones(n,1), 'bo')
                % plot3(obj.xc(:,1), obj.xc(:,2), zeros(M,1), 'rx')
                % axis equal

                figure
                hold on
                [X,Y,Z] = sphere;

                X = obj.vesicle_radius * X;
                Y = obj.vesicle_radius * Y;
                Z = obj.vesicle_radius * Z;

                for i = 1:n

                    if rand(1) < 4/14
                        c = 'b';
                    else
                        c = [0.3, 0.3, 0.3];
                    end

                    surf(X + obj.xv(i,1), Y + obj.xv(i,2), Z + obj.xv(i,3), ...
                        'FaceColor', c, ...
                        'EdgeColor', c, ...
                        'FaceAlpha',0.05, ...
                        'EdgeAlpha',0.15);
                end
                [xp, yp] = circle(obj.vesicle_radius);

                for i = 1:n
                    plot(xp + obj.xv(i,1), yp + obj.xv(i,2), ...
                        'Color', [.7,.7,.7])
                end

                % viscircles(obj.xv(:,1:2), obj.vesicle_radius*ones(1,n), ...
                %     'Color', [0,0,0.2])

                % plot3(obj.xc(:,1), obj.xc(:,2), zeros(M,1), 'rx')
                % viscircles(obj.xc(:,1:2), obj.channel_radius*ones(1,M), 'Color', 'r')

                [X,Y,Z] = cylinder;

                X = obj.channel_radius * X;
                Y = obj.channel_radius * Y;
                Z = 5 * Z;

                for i = 1:M
                    surf(X + obj.xc(i,1), Y + obj.xc(i,2), Z + obj.xc(i,3), ...
                        'FaceColor', 'r', ...
                        'EdgeColor', 'r', ...
                        'FaceAlpha',0.2, ...
                        'EdgeAlpha',0.4);
                end

                view(-24,36)
                zlim([0,100])
                grid on
                axis equal

                title('Ribbon Synapse')
                subtitle(sprintf('presynaptic membrane area = %.2g um^2\n area per channel = %.2g um^2\nconductance = %g nS (%.2g nS/um^2)', ...
                    area*1e-6, area/M*1e-6, 15*1e-3*M, 15*1e-3*M/(area*1e-6)))

                if args.plot_histograms
                    axes('Position',[.7 .05 .2 .2])
                    box on
                    h = histogram(obj.rho, 0:20:(max(obj.rho(:))+20));
                    h.FaceColor = [0.1 0 0.9];
                    xlabel('distance (nm)')
                    ylabel('count')
                    title('dist channel -- vesicle membrane')
    
                    axes('Position',[.45 .05 .2 .2])
                    box on
                    h = histogram(obj.psi(obj.psi>0), 0:20:(max(obj.psi(:))+20));
                    h.FaceColor = [0.9 0 0.1];
                    xlabel('distance (nm)')
                    ylabel('count')
                    title('dist channel -- channel')
                end
                drawnow
            
            end
        end
        function xc = channel_distribution(obj, n, M)
            % Evan
            % There is an element of randomness involved when calculating where channels lie.
            % However the channels gennerally lie on distribution set by param
            
            % EP All coordinates are in nm
            
            param = obj.channel_distribution_parameters;

            xc = NaN(M, 2);
            
            switch obj.channel_distribution_method

                case 'LJ'
                    o = [mean([max(obj.xv(:,1)), min(obj.xv(:,1))]), ...
                         mean([max(obj.xv(:,2)), min(obj.xv(:,2))])];
                    
                    e = [[max(obj.xv(:,1)), min(obj.xv(:,1))]; ...
                         [max(obj.xv(:,2)), min(obj.xv(:,2))]];

                    s = param.s;

                    w = -diff(e(1,:)) + 2*s;
                    l = -diff(e(2,:)) + 2*s;

                    for k = 1:M    
                        x1 = l*(rand(1,1) - 0.5);
                        x2 = w*(rand(1,1) - 0.5);

                        X = o + [x1, x2];

                        xc(k,:) = X;
                    end

                    % vesicles
                    % epsilon0 = 1;
                    % r0 = 150;
                    % n0 = 4;
                    epsilon0 = param.epsilon0;
                    r0 = param.r0;
                    n0 = param.n0;
                    
                    % channels
                    % m1 = 10;
                    % h1 = 20;
                    % s1 = 4;
                    m1 = param.m1;
                    h1 = param.h1;
                    s1 = param.s1;

                    % epsilon1 = 0.05;
                    % r1 = 20;
                    % n1 = 6;

                    r_excl = 10; % nm

                    beta_jump = 10;

                    for it = 1:2000
                        for k = 1:M

                            X = xc(k,:);

                            if it < 10000
                                x1 = l*(rand(1,1) - 0.5);
                                x2 = w*(rand(1,1) - 0.5);    
                                Xnew = o + [x1, x2];
                            else
                                d = beta_jump * rand(1);
                                phi = 2*pi*rand(1);
                                jump = d * [sin(phi), cos(phi)];
                                % jump = beta_jump * (rand(1,2) - 0.5);
                                Xnew = X + jump;
                            end

                            xcc = xc;
                            xcc(k,:) = [];

                            phi_loc = sqrt(sum((obj.xv - X).^2, 2));
                            phi_loc_new = sqrt(sum((obj.xv - Xnew).^2, 2));

                            psi_loc = sqrt(sum((xcc - X).^2, 2));
                            psi_loc_new = sqrt(sum((xcc - Xnew).^2, 2));
                              
                            q = r_excl./psi_loc;
                            q(q > 1) = 1;

                            q_new = r_excl./psi_loc_new;
                            q_new(q_new > 1) = 1;

                            % disp('phi_loc:'); disp(phi_loc);
                            % disp('phi_loc_new:'); disp(phi_loc_new);
                            % disp('psi_loc:'); disp(psi_loc);
                            % disp('psi_loc_new:'); disp(psi_loc_new);

                            F = [ ...
                                lennard_jones(phi_loc, epsilon0, r0, n0);
                                phi_loc.^0.15 / n
                                q.^12
                                - boltzmann(psi_loc, m1, h1, s1);
                                ...boltzmann(phi_loc, 0.1, 100, 20);                                
                                ...14*lennard_jones(min(phi_loc), epsilon0, r0, n0);
                                ...- boltzmann(phi_loc, epsilon0, r0, n0);
                                ...lennard_jones(psi_loc, epsilon1, r1, n1);
                                ];
                            F_new = [ ...
                                lennard_jones(phi_loc_new, epsilon0, r0, n0);
                                phi_loc_new.^0.15 / n
                                q_new.^12
                                - boltzmann(psi_loc_new, m1, h1, s1);
                                ...14*lennard_jones(min(phi_loc_new), epsilon0, r0, n0);
                                ...lennard_jones(psi_loc_new, epsilon1, r1, n1);
                            ];

                            % disp('F:'); disp(F);
                            % disp('F_new:'); disp(F_new);

                            deltaE = sum(F_new) - sum(F);
                            % deltaE is negative if X_new better than X

                            beta = 50;
                            beta = 100;

                            if rand(1) < exp(-beta * deltaE)
                                xc(k,:) = Xnew;
                            end
                        end
                        % disp("IT");disp(it)
                    end

                case 'uniform'
                    % EP
                    % This method didn't work due to a variety of reasons
                    %   So I rewrote it, but you can see the original version below.
                    % https://github.com/evanwporter/cochlea-nerve/blob/7911ffcf2ec1e14a187fbaf46c3635fc3d6ff42d/IHC/RibbonSynapse_v4.m#L429-L434

                    % EP
                    % Randomly distributes channels in a square

                    % Center of vesicles
                    x = mean(obj.xv);

                    % a : lower bound for uniform distribution range
                    % b : upper bound for uniform distribution range.
                    a = -300;
                    b = 300;

                    for c = 1:M
                        xc(c, :) = x + a + (b-a) * rand(1, 2);
                    end
                                        
                case 'uniform_ring'
                    
                    a = param.dist_min;
                    b = param.dist_max;
                    
                    dc = param.exclusion_dist_channel;
                    dv = param.exclusion_dist_vesicle;
                    
                    m = M / n;
                    mustBeInteger(m);
                    
                    for i = 1:n
                        for j = 1:m
                            k = m*(i-1) + j;
                            
                            x = obj.xv(i,:);
                            
                            while true
                                dist = a + (b-a)*rand(1,1);
                                angle = 2*pi*rand(1,1);

                                X = x + dist * [cos(angle), sin(angle)];

                                psi_loc = sqrt(sum((xc - X).^2, 2));
                                phi_loc = sqrt(sum((obj.xv - X).^2, 2));

                                if ~any(psi_loc < dc) && ~any(phi_loc < dv)
                                    break
                                end

                            end
                            
                            xc(k,:) = X;
                        end
                    end
                    
                    
                case 'uniform_band'
                    
                    o = [mean([max(obj.xv(:,1)), min(obj.xv(:,1))]), ...
                         mean([max(obj.xv(:,2)), min(obj.xv(:,2))])];
                    
                    w = param.width;
                    l = param.length;
                    
                    dc = param.exclusion_dist_channel;
                    dv = param.exclusion_dist_vesicle;
                    
                    maxtries = 1000;

                    for k = 1:M    
                        i = 0;
                        while true
                            i = i + 1;
                            x1 = l*(rand(1,1) - 0.5);
                            x2 = w*(rand(1,1) - 0.5);

                            X = o + [x1, x2];

                            psi_loc = sqrt(sum((xc - X).^2, 2));
                            phi_loc = sqrt(sum((obj.xv - X).^2, 2));

                            if ~any(psi_loc < dc) && ~any(phi_loc < dv)
                                break
                            else
                                if i > maxtries
                                    error('Channel distribution not possible')
                                end
                            end

                        end

                        xc(k,:) = X;
                    end
                
                case 'regular_band'
                    
                    o = [mean([max(obj.xv(:,1)), min(obj.xv(:,1))]), ...
                         mean([max(obj.xv(:,2)), min(obj.xv(:,2))])];
                    
                    w = param.width;
                    l = param.length;
                    
                    x = linspace(-l/2, l/2, ceil(M/3));
                    y = linspace(-w/2, w/2, 3);

                    [X, Y] = meshgrid(x,y);

                    xc = [X(:), Y(:)];                        
                    xc = o + xc(1:M,:);
                
                case 'regular_band_4'
                    
                    N = 4;

                    o = [mean([max(obj.xv(:,1)), min(obj.xv(:,1))]), ...
                         mean([max(obj.xv(:,2)), min(obj.xv(:,2))])];
                    
                    w = param.width;
                    l = param.length;
                    
                    x = linspace(-l/2, l/2, ceil(M/N));
                    y = linspace(-w/2, w/2, N);

                    [X, Y] = meshgrid(x,y);

                    xc = [X(:), Y(:)];
                    xc = o + xc(1:M,:);
                
                case 'regular_band_n'
                    
                    N = numel(param.wpos);

                    o = [mean([max(obj.xv(:,1)), min(obj.xv(:,1))]), ...
                         mean([max(obj.xv(:,2)), min(obj.xv(:,2))])];
                    
                    l = param.length;
                    
                    x = linspace(-l/2, l/2, ceil(M/N));
                    y = param.wpos;

                    [X, Y] = meshgrid(x,y);

                    xc = [X(:), Y(:)];
                    xc = o + xc(1:M,:);

                otherwise
                    error('Not set up')
            end
        end
    end
end
```

What is x_pos?